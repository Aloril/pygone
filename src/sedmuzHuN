#!/usr/bin/env python3
import math, os, sys, subprocess, time

A = {'e2e4': 'e7e5', 'd2d4': 'd7d5', 'c2c4': 'c7c5', 'g1f3': 'c7c5'}
B = {'p': 100.0, 'r': 479.0, 'n': 280.0, 'b': 320.0, 'q': 929.0, 'k': 60000.0}
C = {'p': 10.0, 'r': 50.0, 'n': 30.0, 'b': 30.0, 'q': 100.0, 'k': 500.0}

D = [[0,0,0,0,0,0,0,0],
  [78,83,86,73,102,82,85,90],
  [7,29,21,44,40,31,44,7],
  [-17,16,-2,15,14,0,15,-13],
  [-26,3,10,9,6,1,0,-23],
  [-22,9,5,-11,-10,-2,3,-19],
  [-31,8,-7,-37,-36,-14,3,-31],
  [0,0,0,0,0,0,0,0]]
E = [[-66,-53,-75,-75,-10,-55,-58,-70],
  [-3,-6,100,-36,4,62,-4,-14],
  [10,67,1,74,73,27,62,-2],
  [24,24,45,37,33,41,25,17],
  [-1,5,31,21,22,35,2,0],
  [-18,10,13,22,18,15,11,-14],
  [-23,-15,2,0,2,0,-23,-20],
  [-74,-23,-26,-24,-19,-35,-22,-69]]
F = [[-59,-78,-82,-76,-23,-107,-37,-50],
  [-11,20,35,-42,-39,31,2,-22],
  [-9,39,-32,41,52,-10,28,-14],
  [25,17,20,34,26,25,15,10],
  [13,10,17,23,17,16,0,7],
  [14,25,24,15,8,25,20,15],
  [19,20,11,6,7,6,20,16],
  [-7,2,-15,-12,-14,-15,-10,-10]]
G = [[35,29,33,4,37,33,56,50],
  [55,29,56,67,55,62,34,60],
  [19,35,28,33,45,27,25,15],
  [0,5,16,13,18,-4,-9,-6],
  [-28,-35,-16,-21,-13,-29,-46,-30],
  [-42,-28,-42,-25,-25,-35,-26,-46],
  [-53,-38,-31,-26,-29,-43,-44,-53],
  [-30,-24,-18,5,-2,-18,-31,-32]]
H = [[6,1,-8,-104,69,24,88,26],
  [14,32,60,-10,20,76,57,24],
  [-2,43,32,60,72,63,43,2],
  [1,-16,22,17,25,20,-13,-6],
  [-14,-15,-2,-5,-1,-10,-20,-22],
  [-30,-6,-13,-11,-16,-11,-16,-27],
  [-36,-18,0,-19,-15,-15,-21,-38],
  [-39,-30,-31,-13,-31,-36,-34,-42]]
I = [[ 4,54,47,-99,-99,60,83,-62],
  [-32,10,55,56,56,55,10,3],
  [-62,12,-57,44,-67,28,37,-31],
  [-55,50,11,-4,-19,13,0,-49],
  [-55,-43,-52,-28,-51,-47,-8,-50],
  [-47,-42,-43,-79,-64,-32,-29,-32],
  [-4,3,-14,-50,-57,-18,13,4],
  [17,30,-3,-14,6,-1,40,18]] 

J={'p': D,'n': E,'b':F,'r':G,'q':H,'k':I}

class Board:

  K = []
  L = 0
  M = []
  N = []
  O = ''
  P = ''
  Q = 'e1'
  R = 'e8'
  S = []
  T = ''
  nodes = 0

  def __init__(self):
    self.V()
    self.L = 0

  def V(self):
    self.K = [['r','n','b','q','k','b','n','r'],
            ['p','p','p','p','p','p','p','p'],
            ['-','-','-','-','-','-','-','-'],
            ['-','-','-','-','-','-','-','-'],
            ['-','-','-','-','-','-','-','-'],
            ['-','-','-','-','-','-','-','-'],
            ['P','P','P','P','P','P','P','P'],
            ['R','N','B','Q','K','B','N','R'],]
  def W(self, state):
    self.K = state

  def X(self, Y):
    D1 = Y[0:2];
    D2 = Y[2:4]
    D5 = D1[0]
    D7 = D2[0]
    D3 = self.b(D5)
    D6 = abs(int(D1[1]) - 8)
    D4 = self.b(D7)
    D8 = abs(int(D2[1]) - 8)
    D9 = self.K[D6][D3]
    D0 = self.K[D8][D4]
    a = ''
    if (len(Y) > 4):
      a = Y[4:5]
    if (D9.lower() == 'p' and D0 == '-' and D5 != D7):
      self.K[D6][D3] = '-'
      self.K[D8][D4] = D9
      self.K[D6][D4] = '-'
    elif (self.K[D6][D3].lower() == 'k' and (Y == 'e1g1' or Y == 'e1c1' or Y == 'e8g8' or Y == 'e8c8')):
      self.K[D6][D3] = '-'
      if (Y[2] == 'g'):
        self.K[D8][D4 + 1] = '-'

        if (self.L % 2 == 0):
          self.K[D6][D3 + 1] = 'R'
        else:
          self.K[D6][D3 + 1] = 'r'
      else:
        self.K[D6][D4 - 2] = '-'
        if (self.L % 2 == 0):
          self.K[D6][D3 - 1] = 'R'
        else:
          self.K[D6][D3 - 1] = 'r'

      if (self.L % 2 == 0):
        self.K[D6][D4] = 'K'
      else:
        self.K[D6][D4] = 'k'
    else:
      fromState = self.K[D6][D3]
      toState = self.K[D8][D4]
      self.K[D6][D3] = '-'
      if (len(a) > 0):
        if (self.L % 2 == 0):
          self.K[D8][D4] = a.upper()
        else:
          self.K[D8][D4] = a
      else:
        self.K[D8][D4] = fromState
    self.S.append(Y)
    self.L += 1

  def b(self, letter):
    return abs((ord(letter) - 96) - 1)

  def c(self, number):
    return chr(number + 96)

  def d(self):
    for i in range(8) :  
      for j in range(8) : 
        print(self.K[i][j], end=" ") 
      print()

  def e(self): 
    M = []
    N = []
    f = []
    g = []
    self.O = ''
    self.P = ''
    evalState = self.K.copy()
    for row in range(8):  
      for column in range(8): 
        piece = evalState[row][column]
        if (piece != "-"):
          whiteStartCoordinate = self.c(column + 1) + str(abs(row - 8))
          blackStartCoordinate = self.c(column + 1) + str(abs(row - 8))
          if ((piece == 'k' or piece == 'K')):
            if (piece == 'K'):
              isWhite = True
              self.Q = whiteStartCoordinate
            else:
              isWhite = False
              self.R = blackStartCoordinate
            kMoves = {
              1: {'column': (column + 0), 'row': (row + 1)},
              2: {'column': (column + 0), 'row': (row - 1)},
              3: {'column': (column + 1), 'row': (row + 0)},
              4: {'column': (column - 1), 'row': (row + 0)},
              5: {'column': (column + 1), 'row': (row + 1)},
              6: {'column': (column + 1), 'row': (row - 1)},
              7: {'column': (column - 1), 'row': (row + 1)},
              8: {'column': (column - 1), 'row': (row - 1)},
            }
            if isWhite:
              if whiteStartCoordinate == 'e1' and evalState[7][5] == '-' and evalState[7][6] == '-' and evalState[7][7] == 'R':
                M.append(whiteStartCoordinate + 'g1')
              if whiteStartCoordinate == 'e1' and evalState[7][1] == '-' and evalState[7][2] == '-' and evalState[7][3] == '-' and evalState[7][0] == 'R':
                M.append(whiteStartCoordinate + 'c1')
            else:
              if N == 'e8' and evalState[0][1] == '-' and evalState[0][1] == '-' and evalState[0][2] == '-' and evalState[0][0] == 'r':
                bestMove.append(blackStartCoordinate + 'c8')
              if N == 'e8' and evalState[0][5] == '-' and evalState[0][6] == '-' and evalState[0][7] == 'r':
                bestMove.append(blackStartCoordinate + 'g8')
            for key, nMove in kMoves.items():
              if (nMove['column'] >= 0 and nMove['column'] <= 7 and nMove['row'] >= 0 and nMove['row'] <= 7):
                evalPiece = evalState[nMove['row']][nMove['column']]
                if (isWhite):
                  canCapture = (evalPiece != '-' and evalPiece.islower())
                else:
                  canCapture = (evalPiece != '-' and not evalPiece.islower())

                dest = self.c(nMove['column'] + 1) + str(abs(nMove['row'] - 8))

                if (evalPiece == '-' or canCapture):
                  if (isWhite):
                    M.append(whiteStartCoordinate + dest)
                  else:
                    N.append(blackStartCoordinate + dest)
                if (canCapture):
                  if (isWhite):
                    f.append(evalPiece)
                    self.O += dest
                  else:
                    g.append(evalPiece)
                    self.P += dest
          if ((piece == 'p' or piece == 'P')):
            if (piece == 'P'):
              if (row > 1 and evalState[row - 1][column] == '-'):
                M.append(whiteStartCoordinate + self.c(column + 1) + str(abs(row - 9)))
              if (row == 6 and evalState[row - 1][column] == '-' and evalState[row - 2][column] == '-'):
                M.append(whiteStartCoordinate + self.c(column + 1) + str(abs(row - 10)))
              if (row == 1 and evalState[row - 1][column] == '-'):
                M.append(whiteStartCoordinate + self.c(column + 1) + str(abs(row - 9)) + 'q')
              if (((column - 1) >= 0 and (row - 1) >= 0) or ((column + 1) < 8 and (row - 1) >= 0)):
                prom = ''
                if (row == 1):
                  prom = 'q'
                if ((column - 1) >= 0 and evalState[row - 1][column - 1] != '-' and evalState[row - 1][column - 1].islower()):
                  M.append(whiteStartCoordinate + self.c(column) + str(abs(row - 9)) + prom)
                  self.O += self.c(column) + str(abs(row - 9))
                  f.append(evalState[row - 1][column - 1])
                if ((column + 1) < 8 and evalState[row - 1][column + 1] != '-' and evalState[row - 1][column + 1].islower()):
                  M.append(whiteStartCoordinate + self.c(column + 2) + str(abs(row - 9)) + prom)
                  self.O += self.c(column + 2) + str(abs(row - 9))
                  f.append(evalState[row - 1][column + 1])
            else:
              if (row < 6 and evalState[row + 1][column] == '-'):
                N.append(blackStartCoordinate + self.c(column + 1) + str(abs(row - 7)))
              if (row == 1 and evalState[row + 1][column] == '-' and evalState[row + 2][column] == '-'):
                N.append(blackStartCoordinate + self.c(column + 1) + str(abs(row - 6)))
              if (row == 6 and evalState[row + 1][column] == '-'):
                N.append(blackStartCoordinate + self.c(column + 1) + str(abs(row - 7)) + 'q')
              if (((column - 1) >= 0 and (row + 1) < 8) or ((column + 1) < 8 and (row + 1) < 8)):
                prom = ''
                if (row == 6):
                  prom = 'q'

                if ((column + 1) < 8 and evalState[row + 1][column + 1] != '-' and not evalState[row + 1][column + 1].islower()):
                  N.append(blackStartCoordinate + self.c(column + 2) + str(abs(row - 7)) + prom)
                  self.P += self.c(column + 2) + str(abs(row - 7))
                  g.append(evalState[row + 1][column + 1])
                if ((column - 1) >= 0 and evalState[row + 1][column - 1] != '-' and not evalState[row + 1][column - 1].islower()):
                  N.append(blackStartCoordinate + self.c(column) + str(abs(row - 7)) + prom)
                  self.P += self.c(column) + str(abs(row - 7))
                  g.append(evalState[row + 1][column - 1])
          if ((piece == 'n' or piece == 'N')):
            isWhite = (piece == 'N')
            nMoves = {
              1: {'column': (column + 1), 'row': (row - 2)},
              2: {'column': (column - 1), 'row': (row - 2)},
              3: {'column': (column + 2), 'row': (row - 1)},
              4: {'column': (column - 2), 'row': (row - 1)},
              5: {'column': (column + 1), 'row': (row + 2)},
              6: {'column': (column - 1), 'row': (row + 2)},
              7: {'column': (column + 2), 'row': (row + 1)},
              8: {'column': (column - 2), 'row': (row + 1)},
            }
            for key, nMove in nMoves.items():
              if (nMove['column'] >= 0 and nMove['column'] <= 7 and nMove['row'] >= 0 and nMove['row'] <= 7):
                evalPiece = evalState[nMove['row']][nMove['column']]
                if (isWhite):
                  canCapture = (evalPiece != '-' and evalPiece.islower())
                else:
                  canCapture = (evalPiece != '-' and not evalPiece.islower())
                if (evalPiece == '-' or canCapture):
                  dest = self.c(nMove['column'] + 1) + str(abs(nMove['row'] - 8))
                  if (isWhite):
                    M.append(whiteStartCoordinate + dest)
                    if (canCapture):
                      self.O += dest
                      f.append(evalPiece)
                  else:
                    N.append(blackStartCoordinate + dest)
                    if (canCapture):
                      self.P += dest
                      g.append(evalPiece)
          if ((piece == 'r' or piece == 'R')) or ((piece == 'q' or piece == 'Q')):
            isWhite = (piece == 'R' or piece == 'Q')

            horizontalMoves = {
              1: {'column': column, 'row': (row - 1), 'colIncrement': 0, 'rowIncrement': -1},
              2: {'column': column, 'row': (row + 1), 'colIncrement': 0, 'rowIncrement': 1},
              3: {'column': (column - 1), 'row': row, 'colIncrement': -1, 'rowIncrement': 0},
              4: {'column': (column + 1), 'row': row, 'colIncrement': 1, 'rowIncrement': 0}
            }

            for _, hMove in horizontalMoves.items():
              tempRow = hMove['row']
              tempCol = hMove['column']
              while (tempRow >= 0 and tempRow < 8 and tempCol >= 0 and tempCol < 8):
                evalPiece = evalState[tempRow][tempCol]
                canCapture = (isWhite and evalPiece != '-' and evalPiece.islower()) or (not isWhite and evalPiece != '-' and not evalPiece.islower())

                if (evalPiece == '-' or canCapture):
                  dest = self.c(tempCol + 1) + str(abs(tempRow - 8))
                  if isWhite:
                    M.append(whiteStartCoordinate + dest)
                    if (canCapture):
                      self.O += dest
                      f.append(evalPiece)
                  else:
                    N.append(blackStartCoordinate + dest)
                    if (canCapture):
                      self.P += dest
                      g.append(evalPiece)
                  if (canCapture):
                    break
                else:
                  break
                tempRow += hMove['rowIncrement']
                tempCol += hMove['colIncrement']

          if ((piece == 'b' or piece == 'B')) or ((piece == 'q' or piece == 'Q')):
            isWhite = (piece == 'B' or piece == 'Q')

            diagMoves = {
              1: {'column': (column - 1), 'row': (row - 1), 'colIncrement': -1, 'rowIncrement': -1},
              2: {'column': (column + 1), 'row': (row + 1), 'colIncrement': 1, 'rowIncrement': 1},
              3: {'column': (column - 1), 'row': (row + 1), 'colIncrement': -1, 'rowIncrement': 1},
              4: {'column': (column + 1), 'row': (row - 1), 'colIncrement': 1, 'rowIncrement': -1}
            }

            for _, dMove in diagMoves.items():
              tempRow = dMove['row']
              tempCol = dMove['column']
              while (tempRow >= 0 and tempRow < 8 and tempCol >= 0 and tempCol < 8):
                evalPiece = evalState[tempRow][tempCol]
                canCapture = (isWhite and evalPiece != '-' and evalPiece.islower()) or (not isWhite and evalPiece != '-' and not evalPiece.islower())

                if (evalPiece == '-' or canCapture):
                  dest = self.c(tempCol + 1) + str(abs(tempRow - 8))
                  if (isWhite):
                    M.append(whiteStartCoordinate + dest)
                    if (canCapture):
                      self.O += dest
                      f.append(evalPiece)
                  else:
                    N.append(blackStartCoordinate + dest)
                    if (canCapture):
                      self.P += dest
                      g.append(evalPiece)
                  if (canCapture):
                    break
                else:
                  break
                tempRow += dMove['rowIncrement']
                tempCol += dMove['colIncrement']
            
    self.M = M
    self.N = N
    self.f = f
    self.g = g
    return {'M': M, 'N': N}

  def removeIllegalMoves(self, isWhite):
    if (isWhite):
      moves = self.M.copy()
    else:
      moves = self.N.copy()

    masterMoves = moves.copy()
    for move in moves:
      legalMovesBoard = Board()
      legalMovesBoard.W([x[:] for x in self.K.copy()])
      legalMovesBoard.L = self.L
      legalMovesBoard.X(move)
      legalMovesBoard.e()
      if (isWhite):
        kLoc = legalMovesBoard.Q
        availMvs = legalMovesBoard.P
      else:
        kLoc = legalMovesBoard.R
        availMvs = legalMovesBoard.O
      
      if (kLoc in availMvs):
        try:
          masterMoves.remove(move)
        except:
          continue
    return masterMoves

  def boardEvaluation(self):
    bEval = 0
    for row in range(8):
      for column in range(8):
        piece = self.K[row][column]
        isWhite = not piece.islower()
        if (piece != '-'):
          if isWhite:
            bEval += B[piece.lower()] 
            bEval += J[piece.lower()][row][column]
            if (self.R in self.O):
              bEval += (B[piece.lower()] / 10)
          else:
            bEval -= B[piece]
            bEval -= (-1 * J[piece][abs(row-7)][abs(column-7)])
            if (self.Q in self.P):
              bEval -= (B[piece.lower()] / 10)

    for piece in self.f:
      bEval += C[piece.lower()]
    for piece in self.g:
      bEval -= C[piece.lower()]

    return bEval

  def minimaxRoot(self, depth, localBoard, isMaximizing, maxTime):
    lglMvs = localBoard.removeIllegalMoves(localBoard.L % 2 == 0)
    if (localBoard.L == 0):
      possMvs = ['e2e4', 'd2d4', 'c2c4', 'g1f3']
      return [0, possMvs[0], '', 1]
    elif localBoard.L == 1:
      try:
        move = A[localBoard.S[0]]
        return [0, move, '', 1]
      except:
        possMvs = lglMvs
    else:
      possMvs = lglMvs
    if(len(possMvs) == 1):
      return [localBoard.boardEvaluation(), possMvs[0], '', 1]
    bestMove = -9999999
    bestMoveFinal = possMvs[0]
    originalState = [x[:] for x in localBoard.K]
    calcDepth = 1
    for move in possMvs:
      localBoard.nodes += 1
      localBoard.X(move)
      startTime = time.perf_counter() + maxTime
      retMove = self.minimax(depth - 1, -19999999, 19999999, localBoard, not isMaximizing, startTime, move)
      value = max(bestMove, retMove)
      print(move, retMove, isMaximizing)
      localBoard.W([x[:] for x in originalState])
      localBoard.L -= 1
      if( value > bestMove):
        bestMove = value
        bestMoveFinal = move
    gameBoard.T = bestMoveFinal
    return [bestMove, bestMoveFinal, '', calcDepth]

  def minimax(self, depth, alpha, beta, localBoard, isMaximizing, endTime, T):
    localBoard.e()
    possMvs = localBoard.removeIllegalMoves(localBoard.L % 2 == 0)
    startTime = time.perf_counter()
    if depth == 0 or startTime >= endTime:
      offset = 0
      if (T == gameBoard.T):
        if (localBoard.L % 2 == 0):
          offset = -30.0
        else:
          offset = 30.0
      return localBoard.boardEvaluation() + offset
    originalState = [x[:] for x in localBoard.K]
    if(isMaximizing):
      bestMove = -9999999
      for move in possMvs:
        localBoard.nodes += 1
        localBoard.X(move)
        bestMove = max(bestMove, self.minimax(depth - 1, alpha, beta, localBoard, not isMaximizing, endTime, move))
        localBoard.W([x[:] for x in originalState])
        localBoard.L -= 1
        alpha = max(alpha,bestMove)
        if (beta <= alpha):
          return bestMove
      return bestMove
    else:
      bestMove = 9999999
      for move in possMvs:
        localBoard.nodes += 1
        localBoard.X(move)
        bestMove = min(bestMove, self.minimax(depth - 1, alpha, beta, localBoard, not isMaximizing, endTime, move))
        localBoard.W([x[:] for x in originalState])
        localBoard.L -= 1
        beta = min(beta,bestMove)
        if (beta <= alpha):
          return bestMove
      return bestMove

gameBoard = Board()

while True:
  try:
    l = input()
    if l=="quit":
      sys.exit()
    elif l=="uci":
      print("pygone 1.0 by rcostheta")
      print("uciok")
    elif l=="ucinewgame":
      gameBoard = Board()
      gameBoard.L = 0
    elif l=="isready":
      print("readyok")
    elif l.startswith("position"):
      m=l.split()
      offsetMoves = gameBoard.L + 3
      for move in m[offsetMoves:]:
        gameBoard.X(move)
        offsetMoves += 1
      gameBoard.L = (offsetMoves - 3)
    elif l.startswith("go"):
      goBoard = Board()
      goBoard.W([x[:] for x in gameBoard.K])
      goBoard.L = gameBoard.L
      goBoard.e()
      if (gameBoard.L % 2 == 0):
        moveTime = 10 / len(goBoard.M)
      else:
        moveTime = 10 / len(goBoard.N)
      startTime = time.perf_counter()
      (score, move, pv, calcDepth) = goBoard.minimaxRoot(3, goBoard, (gameBoard.L % 2 == 0), moveTime)
      elapsedTime = math.ceil(time.perf_counter() - startTime)
      nps = math.ceil(goBoard.nodes / elapsedTime)
      if (gameBoard.L % 2 == 0):
        score = score * -1
      print("info depth " + str(calcDepth) + " score cp " + str(math.ceil(score)) + " time " + str(elapsedTime) + " nodes " + str(goBoard.nodes) + " nps " + str(nps) + " pv " + move)
      print("bestmove " + move)
      goBoard.d()
  except (KeyboardInterrupt, SystemExit):
    print('quit')
    sys.exit()
  except Exception as e:
    print(e)
    raise