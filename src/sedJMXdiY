#!/usr/bin/env python3
import math,sys,time
A1={'p':100.0,'r':479.0,'n':280.0,'b':320.0,'q':929.0,'k':60000.0}
A3=[[0,0,0,0,0,0,0,0],[78,83,86,73,102,82,85,90],[7,29,21,44,40,31,44,7],[-17,16,-2,15,14,0,15,-13],[-26,3,10,9,6,1,0,-23],[-22,9,5,-11,-10,-2,3,-19],[-31,8,-7,-37,-36,-14,3,-31],[0,0,0,0,0,0,0,0]]
A4=[[-66,-53,-75,-75,-10,-55,-58,-70],[-3,-6,100,-36,4,62,-4,-14],[10,67,1,74,73,27,62,-2],[24,24,45,37,33,41,25,17],[-1,5,31,21,22,35,2,0],[-18,10,13,22,18,15,11,-14],[-23,-15,2,0,2,0,-23,-20],[-74,-23,-26,-24,-19,-35,-22,-69]]
A5=[[-59,-78,-82,-76,-23,-107,-37,-50],[-11,20,35,-42,-39,31,2,-22],[-9,39,-32,41,52,-10,28,-14],[25,17,20,34,26,25,15,10],[13,10,17,23,17,16,0,7],[14,25,24,15,8,25,20,15],[19,20,11,6,7,6,20,16],[-7,2,-15,-12,-14,-15,-10,-10]]
A6=[[35,29,33,4,37,33,56,50],[55,29,56,67,55,62,34,60],[19,35,28,33,45,27,25,15],[0,5,16,13,18,-4,-9,-6],[-28,-35,-16,-21,-13,-29,-46,-30],[-42,-28,-42,-25,-25,-35,-26,-46],[-53,-38,-31,-26,-29,-43,-44,-53],[-30,-24,-18,5,-2,-18,-31,-32]]
A7=[[6,1,-8,-104,69,24,88,26],[14,32,60,-10,20,76,57,24],[-2,43,32,60,72,63,43,2],[1,-16,22,17,25,20,-13,-6],[-14,-15,-2,-5,-1,-10,-20,-22],[-30,-6,-13,-11,-16,-11,-16,-27],[-36,-18,0,-19,-15,-15,-21,-38],[-39,-30,-31,-13,-31,-36,-34,-42]]
A8=[[4,54,47,-99,-99,60,83,-62],[-32,10,55,56,56,55,10,3],[-62,12,-57,44,-67,28,37,-31],[-55,50,11,-4,-19,13,0,-49],[-55,-43,-52,-28,-51,-47,-8,-50],[-47,-42,-43,-79,-64,-32,-29,-32],[-4,3,-14,-50,-57,-18,13,4],[22,30,-3,-14,6,-1,40,26]]
A9={'p':A3,'n':A4,'b':A5,'r':A6,'q':A7,'k':A8}
A0=50000
TTEXACT=1
TTLOWER=2
TTUPPER=3
isupper=lambda c:'A'<=c<='Z'
islower=lambda c:'a'<=c<='z'
def B1(letter):
 return abs((ord(letter)-96)-1)
def B2(number):
 return chr(number+96)
class Board:
 B3=[]
 B4=0
 B5=[]
 B6=[]
 B7=''
 B8=''
 B9='e1'
 B0='e8'
 C1_pieces=[]
 C1=[]
 tt_set={}
 def __init__(self):
  self.reset()
 def reset(self):
  self.B31()
  self.B4=0
  self.B5=[]
  self.B6=[]
  self.D9=[]
  self.D0=[]
  self.B7=''
  self.B8=''
 def B31(self):
  self.B3=[['r','n','b','q','k','b','n','r'],['p']*8,['-']*8,['-']*8,['-']*8,['-']*8,['P']*8,['R','N','B','Q','K','B','N','R']]
 def B32(self,state):
  self.B3=state
 def D1(self,C2,C3=False,C4=False,C91='',C01=''):
  C5=B1(C2[0:1])
  C6=abs(int(C2[1:2])-8)
  C7=B1(C2[2:3])
  C8=abs(int(C2[3:4])-8)
  C9=self.B3[C6][C5]
  C0=self.B3[C8][C7]
  if len(C91)>0:
   C9=C91
  if len(C01)>0:
   C0=C01
  if C3:
   C9='-'
   C0='P' if(self.B4%2==0)else 'p'
  if C4:
   D2=1
   if C2[0:1]=='c':
    D2=-2
    self.B3[C8][C7-1]='-'
   else:
    self.B3[C8][C7+2]='-'
   self.B3[C6][C5+D2]='R' if(self.B4%2==0)else 'r'
   self.B3[C8][C7]='K' if(self.B4%2==0)else 'k'
   self.B3[C8][C7+D2]='-'
   return[C9,C0]
  D3=""
  if len(C2)>4:
   D3=C2[4:5]
  if(C9 in('P','p')and C0=='-' and C2[0:1]!=C2[2:3]and len(C91)==0 and len(C01)==0):
   self.B3[C6][C5]='-'
   self.B3[C8][C7]=C9
   self.B3[C6][C7]='-'
  elif(C9 in('K','k')and C2 in('e1g1','e1c1','e8g8','e8c8')):
   self.B3[C6][C5]='-'
   if C2[2]=='g':
    self.B3[C8][C7+1]='-'
    if self.B4%2==0:
     self.B3[C6][C5+1]='R'
    else:
     self.B3[C6][C5+1]='r'
   else:
    self.B3[C8][C7-2]='-'
    if self.B4%2==0:
     self.B3[C6][C5-1]='R'
    else:
     self.B3[C6][C5-1]='r'
   if self.B4%2==0:
    self.B3[C8][C7]='K'
   else:
    self.B3[C8][C7]='k'
  else:
   if len(C01)==0:
    self.B3[C6][C5]='-'
   else:
    self.B3[C6][C5]=C01
   if D3!="":
    if self.B4%2==0:
     self.B3[C8][C7]=D3.upper()
    else:
     self.B3[C8][C7]=D3
   else:
    if len(C91)==0:
     self.B3[C8][C7]=C9
    else:
     self.B3[C8][C7]=C91
  return[C9,C0]
 def D4(self,C2):
  (C9,C0)=self.D1(C2)
  self.C1.append(C2)
  self.C1_pieces.append([C2,C9,C0])
  self.B4+=1
 def D6(self):
  self.C1.pop()
  old_move=self.C1_pieces.pop()
  C2=old_move[0]
  C9=old_move[1]
  C0=old_move[2]
  C4=(C2 in('e1g1','e1c1')and C9=='K' and C0=='R')or(C2 in('e8g8','e8c8')and C9=='k' and C0=='r')
  self.D1(C2[2:4]+C2[0:2],len(C2)>4,C4,C9,C0)
  self.B4-=1
 def D7(self):
  for i in range(8):
   for j in range(8):
    pr(self.B3[i][j],end=" ")
   pr()
 def board_to_hash(self):
  result=[]
  for _list in self.B3:
   result+=_list
  return hash(''.join(result))
 def D8(self):
  self.B5=[]
  self.B6=[]
  self.D9=[]
  self.D0=[]
  self.B7=''
  self.B8=''
  E1=self.B3.copy()
  for E2 in range(8):
   for E3 in range(8):
    piece=E1[E2][E3]
    if piece=="-":
     continue
    E5=B2(E3+1)+str(abs(E2-8))
    E6=B2(E3+1)+str(abs(E2-8))
    if piece in('k','K'):
     if piece=='K':
      E7=True
      self.B9=E5
     else:
      E7=False
      self.B0=E6
     king_moves={1:{'E3':(E3+0),'E2':(E2+1)},2:{'E3':(E3+0),'E2':(E2-1)},3:{'E3':(E3+1),'E2':(E2+0)},4:{'E3':(E3-1),'E2':(E2+0)},5:{'E3':(E3+1),'E2':(E2+1)},6:{'E3':(E3+1),'E2':(E2-1)},7:{'E3':(E3-1),'E2':(E2+1)},8:{'E3':(E3-1),'E2':(E2-1)},}
     if E7:
      if E5=='e1' and E1[7][5]=='-' and E1[7][6]=='-' and E1[7][7]=='R':
       self.B5.append(E5+'g1')
      if E5=='e1' and E1[7][1]=='-' and E1[7][2]=='-' and E1[7][3]=='-' and E1[7][0]=='R':
       self.B5.append(E5+'c1')
     else:
      if E6=='e8' and E1[0][1]=='-' and E1[0][1]=='-' and E1[0][2]=='-' and E1[0][0]=='r':
       self.B6.append(E6+'c8')
      if E6=='e8' and E1[0][5]=='-' and E1[0][6]=='-' and E1[0][7]=='r':
       self.B6.append(E6+'g8')
     for _,k_move in king_moves.items():
      if(k_move['E3']>=0 and k_move['E3']<=7 and k_move['E2']>=0 and k_move['E2']<=7):
       eval_piece=E1[k_move['E2']][k_move['E3']]
       if E7:
        can_capture=(eval_piece!='-' and eval_piece.islower())
       else:
        can_capture=(eval_piece!='-' and eval_piece.isupper())
       dest=B2(k_move['E3']+1)+str(abs(k_move['E2']-8))
       if eval_piece=='-' or can_capture:
        if E7:
         self.B5.append(E5+dest)
        else:
         self.B6.append(E6+dest)
       if can_capture:
        if E7:
         self.D9.append([eval_piece,piece])
         self.B7+=dest
        else:
         self.D0.append([eval_piece,piece])
         self.B8+=dest
    if piece in('p','P'):
     if piece=='P':
      if E2>1 and E1[E2-1][E3]=='-':
       self.B5.append(E5+B2(E3+1)+str(abs(E2-9)))
      if E2==6 and E1[E2-1][E3]=='-' and E1[E2-2][E3]=='-':
       self.B5.append(E5+B2(E3+1)+str(abs(E2-10)))
      if E2==1 and E1[E2-1][E3]=='-':
       self.B5.append(E5+B2(E3+1)+str(abs(E2-9))+'q')
      if((E3-1)>=0 and(E2-1)>=0)or((E3+1)<8 and(E2-1)>=0):
       prom=''
       if E2==1:
        prom='q'
       if(E3-1)>=0 and E1[E2-1][E3-1]!='-' and E1[E2-1][E3-1].islower():
        self.B5.append(E5+B2(E3)+str(abs(E2-9))+prom)
        self.B7+=B2(E3)+str(abs(E2-9))
        self.D9.append([E1[E2-1][E3-1],piece])
       if(E3+1)<8 and E1[E2-1][E3+1]!='-' and E1[E2-1][E3+1].islower():
        self.B5.append(E5+B2(E3+2)+str(abs(E2-9))+prom)
        self.B7+=B2(E3+2)+str(abs(E2-9))
        self.D9.append([E1[E2-1][E3+1],piece])
     else:
      if E2<6 and E1[E2+1][E3]=='-':
       self.B6.append(E6+B2(E3+1)+str(abs(E2-7)))
      if E2==1 and E1[E2+1][E3]=='-' and E1[E2+2][E3]=='-':
       self.B6.append(E6+B2(E3+1)+str(abs(E2-6)))
      if E2==6 and E1[E2+1][E3]=='-':
       self.B6.append(E6+B2(E3+1)+str(abs(E2-7))+'q')
      if((E3-1)>=0 and(E2+1)<8)or((E3+1)<8 and(E2+1)<8):
       prom=''
       if E2==6:
        prom='q'
       if(E3+1)<8 and E1[E2+1][E3+1]!='-' and E1[E2+1][E3+1].isupper():
        self.B6.append(E6+B2(E3+2)+str(abs(E2-7))+prom)
        self.B8+=B2(E3+2)+str(abs(E2-7))
        self.D0.append([E1[E2+1][E3+1],piece])
       if(E3-1)>=0 and E1[E2+1][E3-1]!='-' and E1[E2+1][E3-1].isupper():
        self.B6.append(E6+B2(E3)+str(abs(E2-7))+prom)
        self.B8+=B2(E3)+str(abs(E2-7))
        self.D0.append([E1[E2+1][E3-1],piece])
    if piece in('n','N'):
     E7=(piece=='N')
     night_moves={1:{'E3':(E3+1),'E2':(E2-2)},2:{'E3':(E3-1),'E2':(E2-2)},3:{'E3':(E3+2),'E2':(E2-1)},4:{'E3':(E3-2),'E2':(E2-1)},5:{'E3':(E3+1),'E2':(E2+2)},6:{'E3':(E3-1),'E2':(E2+2)},7:{'E3':(E3+2),'E2':(E2+1)},8:{'E3':(E3-2),'E2':(E2+1)}}
     for _,n_move in night_moves.items():
      if n_move['E3']>=0 and n_move['E3']<=7 and n_move['E2']>=0 and n_move['E2']<=7:
       eval_piece=E1[n_move['E2']][n_move['E3']]
       if E7:
        can_capture=(eval_piece!='-' and eval_piece.islower())
       else:
        can_capture=(eval_piece!='-' and eval_piece.isupper())
       if eval_piece=='-' or can_capture:
        dest=B2(n_move['E3']+1)+str(abs(n_move['E2']-8))
        if E7:
         self.B5.append(E5+dest)
         if can_capture:
          self.B7+=dest
          self.D9.append([eval_piece,piece])
        else:
         self.B6.append(E6+dest)
         if can_capture:
          self.B8+=dest
          self.D0.append([eval_piece,piece])
    if piece in('r','R')or piece in('q','Q'):
     E7=piece in('R','Q')
     horizontal_moves={1:{'E3':E3,'E2':(E2-1),'E24':0,'E23':-1},2:{'E3':E3,'E2':(E2+1),'E24':0,'E23':1},3:{'E3':(E3-1),'E2':E2,'E24':-1,'E23':0},4:{'E3':(E3+1),'E2':E2,'E24':1,'E23':0}}
     for _,h_move in horizontal_moves.items():
      E21=h_move['E2']
      E22=h_move['E3']
      while E21 in range(8)and E22 in range(8):
       eval_piece=E1[E21][E22]
       can_capture=(E7 and eval_piece!='-' and eval_piece.islower())or(not E7 and eval_piece!='-' and eval_piece.isupper())
       if eval_piece=='-' or can_capture:
        dest=B2(E22+1)+str(abs(E21-8))
        if E7:
         self.B5.append(E5+dest)
         if can_capture:
          self.B7+=dest
          self.D9.append([eval_piece,piece])
        else:
         self.B6.append(E6+dest)
         if can_capture:
          self.B8+=dest
          self.D0.append([eval_piece,piece])
        if can_capture:
         break
       else:
        break
       E21+=h_move['E23']
       E22+=h_move['E24']
    if piece in('b','B')or piece in('q','Q'):
     E7=piece in('B','Q')
     diag_moves={1:{'E3':(E3-1),'E2':(E2-1),'E24':-1,'E23':-1},2:{'E3':(E3+1),'E2':(E2+1),'E24':1,'E23':1},3:{'E3':(E3-1),'E2':(E2+1),'E24':-1,'E23':1},4:{'E3':(E3+1),'E2':(E2-1),'E24':1,'E23':-1}}
     for _,d_move in diag_moves.items():
      E21=d_move['E2']
      E22=d_move['E3']
      while E21 in range(8)and E22 in range(8):
       eval_piece=E1[E21][E22]
       can_capture=(E7 and eval_piece in('p','r','b','q','k'))or(not E7 and eval_piece in('P','R','B','Q','K'))
       if eval_piece=='-' or can_capture:
        dest=B2(E22+1)+str(abs(E21-8))
        if E7:
         self.B5.append(E5+dest)
         if can_capture:
          self.B7+=dest
          self.D9.append([eval_piece,piece])
        else:
         self.B6.append(E6+dest)
         if can_capture:
          self.B8+=dest
          self.D0.append([eval_piece,piece])
        if can_capture:
         break
       else:
        break
       E21+=d_move['E23']
       E22+=d_move['E24']
  move_string=''.join(self.C1)
  if self.B4%2==0:
   move_copy=self.B5.copy()
   for move in move_copy:
    override_remove=((move=='e1g1' and('e1' in move_string or 'f1' in move_string or 'g1' in move_string))or(move=='e1c1' and('e1' in move_string or 'd1' in move_string or 'c1' in move_string)))
    if override_remove:
     try:
      self.B5.remove(move)
     except Exception:
      continue
  else:
   move_copy=self.B6.copy()
   for move in move_copy:
    override_remove=((move=='e8g8' and('e8' in move_string or 'f8' in move_string or 'g8' in move_string))or(move=='e8c8' and('e8' in move_string or 'd8' in move_string or 'c8' in move_string)))
    if override_remove:
     try:
      self.B6.remove(move)
     except Exception:
      continue
 def in_check(self,E7,debug=False):
  if E7:
   for(attacked,attacker)in self.D0:
    if attacked=='K':
     return True
   return False
  else:
   for(attacked,attacker)in self.D9:
    if attacked=='k':
     return True
   return False
 def get_side_moves(self,E7):
  if E7:
   return self.B5
  return self.B6
 def order_moves(self,moves,E7):
  sort_moves={}
  for move in moves:
   self.D4(move)
   sort_moves[self.board_evaluation()]=move
   self.D6()
  sort_moves=sorted(sort_moves.items(),key=lambda x:x[0],reverse=not E7)
  return_moves=[]
  for sort_move in sort_moves:
   return_moves.append(sort_move[1])
  return return_moves
 def board_evaluation(self):
  b_eval=0
  for E2 in range(8):
   for E3 in range(8):
    piece=self.B3[E2][E3]
    E7=piece.isupper()
    if piece!='-':
     if E7:
      b_eval+=A1[piece.lower()]
      b_eval+=(A9[piece.lower()][E2][E3]/5)
     else:
      b_eval-=A1[piece]
      b_eval-=(A9[piece][abs(E2-7)][abs(E3-7)]/5)
  return b_eval
class Search:
 nodes=0
 depth=0
 end_time=0
 def iterative_search(self,local_board,depth,move_time):
  start_time=time.perf_counter()
  self.end_time=time.perf_counter()+move_time
  self.depth=0
  while True:
   self.depth+=1
   depth-=1
   (iterative_score,iterative_move)=self.search(local_board,self.depth)
   elapsed_time=math.ceil(time.perf_counter()-start_time)
   nps=math.ceil(self.nodes/elapsed_time)
   print("info depth "+str(self.depth)+" score cp "+str(math.ceil(iterative_score))+" time "+str(elapsed_time)+" nodes "+str(self.nodes)+" nps "+str(nps)+" pv "+str(iterative_move))
   if time.perf_counter()>=self.end_time or depth<1:
    break
  return[iterative_score,iterative_move]
 def search(self,local_board,depth):
  E7=local_board.B4%2==0
  if E7:
   eval_sign=1
  else:
   eval_sign=-1
  global_score=-1e8
  chosen_move=None
  alpha=-1e8
  beta=1e8
  local_board.D8()
  poss_mvs=local_board.get_side_moves(E7)
  poss_mvs=local_board.order_moves(poss_mvs,E7)
  depth=max(depth,1)
  for move in poss_mvs:
   self.nodes+=1
   local_board.D4(move)
   local_board.D8()
   if not local_board.in_check(E7):
    local_score=self.negamax(local_board,alpha,beta,depth-1,-eval_sign)
    if local_score>=global_score:
     global_score=local_score
     chosen_move=move
   local_board.D6()
  return[global_score,chosen_move]
 def negamax(self,local_board,alpha,beta,depth,eval_sign):
  E7=local_board.B4%2==0
  local_board.D8()
  poss_mvs=local_board.get_side_moves(E7)
  poss_mvs=local_board.order_moves(poss_mvs,E7)
  if len(poss_mvs)==0 or(depth<=0):
   return eval_sign*local_board.board_evaluation()
  value=-1e8
  for move in poss_mvs:
   local_board.D4(move)
   local_board.D8()
   if not local_board.in_check(E7):
    self.nodes+=1
    value=max(value,self.negamax(local_board,alpha,beta,depth-1,-eval_sign))
    alpha=max(alpha,value)
   local_board.D6()
   if alpha>=beta:
    break
  return value
 def transposition_table_lookup(self,local_board):
  board_hash=local_board.board_to_hash()
  if board_hash in game_board.tt_set.keys():
   tt_entry=game_board.tt_set[board_hash]
  else:
   tt_entry=TranspositionTableEntry()
   tt_entry.board_hash=board_hash
   game_board.tt_set[board_hash]=tt_entry
  return tt_entry
 def update_transposition_table_entry(self,tt_entry):
  game_board.tt_set[tt_entry.board_hash].value=tt_entry.value
  game_board.tt_set[tt_entry.board_hash].flag=tt_entry.flag
  game_board.tt_set[tt_entry.board_hash].depth=tt_entry.depth
  game_board.tt_set[tt_entry.board_hash].value=tt_entry.value
class TranspositionTableEntry:
 value=-1e8
 flag=TTLOWER
 depth=0
 board_hash=''
game_board=Board()
def main():
 while True:
  try:
   line=input()
   if line=="quit":
    sys.exit()
   elif line=="uci":
    print("pygone 1.0 by rcostheta")
    print("uciok")
   elif line=="ucinewgame":
    game_board.reset()
   elif line=="eval":
    game_board.D8()
    print('wval: ',game_board.get_side_moves(1))
    print('bval: ',game_board.get_side_moves(0))
    print(game_board.board_evaluation(1))
    print(game_board.tt_set)
    game_board.D7()
   elif line=="isready":
    print("readyok")
   elif line.startswith("position"):
    moves=line.split()
    offset_moves=game_board.B4+3
    for position_move in moves[offset_moves:]:
     game_board.D4(position_move)
     offset_moves+=1
    game_board.B4=(offset_moves-3)
   elif line.startswith("go"):
    go_board=Board()
    go_board.B32([x[:]for x in game_board.B3.copy()])
    go_board.B4=game_board.B4
    go_board.D8()
    white_time=1000000
    black_time=1000000
    go_depth=8
    args=line.split()
    for key,arg in enumerate(args):
     if arg=='wtime':
      white_time=int(args[key+1])
     if arg=='btime':
      black_time=int(args[key+1])
     if arg=='depth':
      go_depth=int(args[key+1])
    time_move_calc=40
    if game_board.B4>38:
     time_move_calc=2
    else:
     time_move_calc=40-game_board.B4
    if game_board.B4%2==0:
     move_time=white_time/(time_move_calc*1000)
    else:
     move_time=black_time/(time_move_calc*1000)
    move_time-=3
    if move_time<8:
     move_time=8
    if move_time<10 and go_depth>4:
     go_depth=4
    searcher=Search()
    start_time=time.perf_counter()
    (score,move)=searcher.iterative_search(go_board,go_depth,move_time)
    print("bestmove "+move)
  except(KeyboardInterrupt,SystemExit):
   print('quit')
   sys.exit()
  except Exception as exc:
   print(exc)
   raise
main()
# Created by pyminifier (https://github.com/liftoff/pyminifier)
